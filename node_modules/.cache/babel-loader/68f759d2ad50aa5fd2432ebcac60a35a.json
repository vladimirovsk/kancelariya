{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _off = _interopRequireDefault(require(\"dom-helpers/events/off\"));\n\nvar _on = _interopRequireDefault(require(\"dom-helpers/events/on\"));\n\nvar _scrollLeft = _interopRequireDefault(require(\"dom-helpers/query/scrollLeft\"));\n\nvar _scrollTop = _interopRequireDefault(require(\"dom-helpers/query/scrollTop\"));\n\nvar _requestAnimationFrame = _interopRequireDefault(require(\"dom-helpers/util/requestAnimationFrame\"));\n\nvar _invariant = _interopRequireDefault(require(\"invariant\"));\n\nvar _utils = require(\"./utils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n/* eslint-disable no-underscore-dangle */\n// Try at most this many times to scroll, to avoid getting stuck.\n\n\nvar MAX_SCROLL_ATTEMPTS = 2;\n\nvar ScrollBehavior = /*#__PURE__*/function () {\n  function ScrollBehavior(_ref) {\n    var _this = this;\n\n    var addTransitionHook = _ref.addTransitionHook,\n        stateStorage = _ref.stateStorage,\n        getCurrentLocation = _ref.getCurrentLocation,\n        shouldUpdateScroll = _ref.shouldUpdateScroll;\n\n    this._restoreScrollRestoration = function () {\n      /* istanbul ignore if: not supported by any browsers on Travis */\n      if (_this._oldScrollRestoration) {\n        try {\n          window.history.scrollRestoration = _this._oldScrollRestoration;\n        } catch (e) {\n          /* silence */\n        }\n      }\n    };\n\n    this._onWindowScroll = function () {\n      if (_this._ignoreScrollEvents) {\n        // Don't save the scroll position until the transition is complete\n        return;\n      } // It's possible that this scroll operation was triggered by what will be a\n      // `POP` transition. Instead of updating the saved location immediately, we\n      // have to enqueue the update, then potentially cancel it if we observe a\n      // location update.\n\n\n      if (!_this._saveWindowPositionHandle) {\n        _this._saveWindowPositionHandle = (0, _requestAnimationFrame[\"default\"])(_this._saveWindowPosition);\n      }\n\n      if (_this._windowScrollTarget) {\n        var _this$_windowScrollTa = _this._windowScrollTarget,\n            xTarget = _this$_windowScrollTa[0],\n            yTarget = _this$_windowScrollTa[1];\n        var x = (0, _scrollLeft[\"default\"])(window);\n        var y = (0, _scrollTop[\"default\"])(window);\n\n        if (x === xTarget && y === yTarget) {\n          _this._windowScrollTarget = null;\n\n          _this._cancelCheckWindowScroll();\n        }\n      }\n    };\n\n    this._saveWindowPosition = function () {\n      _this._saveWindowPositionHandle = null;\n\n      _this._savePosition(null, window);\n    };\n\n    this._checkWindowScrollPosition = function () {\n      _this._checkWindowScrollHandle = null; // We can only get here if scrollTarget is set. Every code path that unsets\n      // scroll target also cancels the handle to avoid calling this handler.\n      // Still, check anyway just in case.\n\n      /* istanbul ignore if: paranoid guard */\n\n      if (!_this._windowScrollTarget) {\n        return Promise.resolve();\n      }\n\n      _this.scrollToTarget(window, _this._windowScrollTarget);\n\n      ++_this._numWindowScrollAttempts;\n      /* istanbul ignore if: paranoid guard */\n\n      if (_this._numWindowScrollAttempts >= MAX_SCROLL_ATTEMPTS) {\n        // This might happen if the scroll position was already set to the target\n        _this._windowScrollTarget = null;\n        return Promise.resolve();\n      }\n\n      return new Promise(function (resolve) {\n        _this._checkWindowScrollHandle = (0, _requestAnimationFrame[\"default\"])(function () {\n          return resolve(_this._checkWindowScrollPosition());\n        });\n      });\n    };\n\n    this._stateStorage = stateStorage;\n    this._getCurrentLocation = getCurrentLocation;\n    this._shouldUpdateScroll = shouldUpdateScroll; // This helps avoid some jankiness in fighting against the browser's\n    // default scroll behavior on `POP` transitions.\n\n    /* istanbul ignore else: Travis browsers all support this */\n\n    if ('scrollRestoration' in window.history && // Unfortunately, Safari on iOS freezes for 2-6s after the user swipes to\n    // navigate through history with scrollRestoration being 'manual', so we\n    // need to detect this browser and exclude it from the following code\n    // until this bug is fixed by Apple.\n    !(0, _utils.isMobileSafari)()) {\n      this._oldScrollRestoration = window.history.scrollRestoration;\n\n      try {\n        window.history.scrollRestoration = 'manual'; // Scroll restoration persists across page reloads. We want to reset\n        // this to the original value, so that we can let the browser handle\n        // restoring the initial scroll position on server-rendered pages.\n\n        (0, _on[\"default\"])(window, 'beforeunload', this._restoreScrollRestoration);\n      } catch (e) {\n        this._oldScrollRestoration = null;\n      }\n    } else {\n      this._oldScrollRestoration = null;\n    }\n\n    this._saveWindowPositionHandle = null;\n    this._checkWindowScrollHandle = null;\n    this._windowScrollTarget = null;\n    this._numWindowScrollAttempts = 0;\n    this._ignoreScrollEvents = false;\n    this._scrollElements = {}; // We have to listen to each window scroll update rather than to just\n    // location updates, because some browsers will update scroll position\n    // before emitting the location change.\n\n    (0, _on[\"default\"])(window, 'scroll', this._onWindowScroll);\n    this._removeTransitionHook = addTransitionHook(function () {\n      _requestAnimationFrame[\"default\"].cancel(_this._saveWindowPositionHandle);\n\n      _this._saveWindowPositionHandle = null;\n      Object.keys(_this._scrollElements).forEach(function (key) {\n        var scrollElement = _this._scrollElements[key];\n\n        _requestAnimationFrame[\"default\"].cancel(scrollElement.savePositionHandle);\n\n        scrollElement.savePositionHandle = null; // It's fine to save element scroll positions here, though; the browser\n        // won't modify them.\n\n        if (!_this._ignoreScrollEvents) {\n          _this._saveElementPosition(key);\n        }\n      });\n    });\n  }\n\n  var _proto = ScrollBehavior.prototype;\n\n  _proto.registerElement = function registerElement(key, element, shouldUpdateScroll, context) {\n    var _this2 = this;\n\n    !!this._scrollElements[key] ? process.env.NODE_ENV !== \"production\" ? (0, _invariant[\"default\"])(false, 'ScrollBehavior: There is already an element registered for `%s`.', key) : invariant(false) : void 0;\n\n    var saveElementPosition = function saveElementPosition() {\n      _this2._saveElementPosition(key);\n    };\n\n    var scrollElement = {\n      element: element,\n      shouldUpdateScroll: shouldUpdateScroll,\n      savePositionHandle: null,\n      onScroll: function onScroll() {\n        if (!scrollElement.savePositionHandle && !_this2._ignoreScrollEvents) {\n          scrollElement.savePositionHandle = (0, _requestAnimationFrame[\"default\"])(saveElementPosition);\n        }\n      }\n    }; // In case no scrolling occurs, save the initial position\n\n    if (!scrollElement.savePositionHandle && !this._ignoreScrollEvents) {\n      scrollElement.savePositionHandle = (0, _requestAnimationFrame[\"default\"])(saveElementPosition);\n    }\n\n    this._scrollElements[key] = scrollElement;\n    (0, _on[\"default\"])(element, 'scroll', scrollElement.onScroll);\n\n    this._updateElementScroll(key, null, context);\n  };\n\n  _proto.unregisterElement = function unregisterElement(key) {\n    !this._scrollElements[key] ? process.env.NODE_ENV !== \"production\" ? (0, _invariant[\"default\"])(false, 'ScrollBehavior: There is no element registered for `%s`.', key) : invariant(false) : void 0;\n    var _this$_scrollElements = this._scrollElements[key],\n        element = _this$_scrollElements.element,\n        onScroll = _this$_scrollElements.onScroll,\n        savePositionHandle = _this$_scrollElements.savePositionHandle;\n    (0, _off[\"default\"])(element, 'scroll', onScroll);\n\n    _requestAnimationFrame[\"default\"].cancel(savePositionHandle);\n\n    delete this._scrollElements[key];\n  };\n\n  _proto.updateScroll = function updateScroll(prevContext, context) {\n    var _this3 = this;\n\n    this._updateWindowScroll(prevContext, context).then(function () {\n      // Save the position immediately after a transition so that if no\n      // scrolling occurs, there is still a saved position\n      if (!_this3._saveWindowPositionHandle) {\n        _this3._saveWindowPositionHandle = (0, _requestAnimationFrame[\"default\"])(_this3._saveWindowPosition);\n      }\n    });\n\n    Object.keys(this._scrollElements).forEach(function (key) {\n      _this3._updateElementScroll(key, prevContext, context);\n    });\n  };\n\n  _proto.stop = function stop() {\n    this._restoreScrollRestoration();\n\n    (0, _off[\"default\"])(window, 'scroll', this._onWindowScroll);\n\n    this._cancelCheckWindowScroll();\n\n    this._removeTransitionHook();\n  };\n\n  _proto.startIgnoringScrollEvents = function startIgnoringScrollEvents() {\n    this._ignoreScrollEvents = true;\n  };\n\n  _proto.stopIgnoringScrollEvents = function stopIgnoringScrollEvents() {\n    this._ignoreScrollEvents = false;\n  };\n\n  _proto._cancelCheckWindowScroll = function _cancelCheckWindowScroll() {\n    _requestAnimationFrame[\"default\"].cancel(this._checkWindowScrollHandle);\n\n    this._checkWindowScrollHandle = null;\n  };\n\n  _proto._saveElementPosition = function _saveElementPosition(key) {\n    var scrollElement = this._scrollElements[key];\n    scrollElement.savePositionHandle = null;\n\n    this._savePosition(key, scrollElement.element);\n  };\n\n  _proto._savePosition = function _savePosition(key, element) {\n    this._stateStorage.save(this._getCurrentLocation(), key, [(0, _scrollLeft[\"default\"])(element), (0, _scrollTop[\"default\"])(element)]);\n  };\n\n  _proto._updateWindowScroll = function _updateWindowScroll(prevContext, context) {\n    // Whatever we were doing before isn't relevant any more.\n    this._cancelCheckWindowScroll();\n\n    this._windowScrollTarget = this._getScrollTarget(null, this._shouldUpdateScroll, prevContext, context); // Updating the window scroll position is really flaky. Just trying to\n    // scroll it isn't enough. Instead, try to scroll a few times until it\n    // works.\n\n    this._numWindowScrollAttempts = 0;\n    return this._checkWindowScrollPosition();\n  };\n\n  _proto._updateElementScroll = function _updateElementScroll(key, prevContext, context) {\n    var _this$_scrollElements2 = this._scrollElements[key],\n        element = _this$_scrollElements2.element,\n        shouldUpdateScroll = _this$_scrollElements2.shouldUpdateScroll;\n\n    var scrollTarget = this._getScrollTarget(key, shouldUpdateScroll, prevContext, context);\n\n    if (!scrollTarget) {\n      return;\n    } // Unlike with the window, there shouldn't be any flakiness to deal with\n    // here.\n\n\n    this.scrollToTarget(element, scrollTarget);\n  };\n\n  _proto._getDefaultScrollTarget = function _getDefaultScrollTarget(location) {\n    var hash = location.hash;\n\n    if (hash && hash !== '#') {\n      return hash.charAt(0) === '#' ? hash.slice(1) : hash;\n    }\n\n    return [0, 0];\n  };\n\n  _proto._getScrollTarget = function _getScrollTarget(key, shouldUpdateScroll, prevContext, context) {\n    var scrollTarget = shouldUpdateScroll ? shouldUpdateScroll.call(this, prevContext, context) : true;\n\n    if (!scrollTarget || Array.isArray(scrollTarget) || typeof scrollTarget === 'string') {\n      return scrollTarget;\n    }\n\n    var location = this._getCurrentLocation();\n\n    return this._getSavedScrollTarget(key, location) || this._getDefaultScrollTarget(location);\n  };\n\n  _proto._getSavedScrollTarget = function _getSavedScrollTarget(key, location) {\n    if (location.action === 'PUSH') {\n      return null;\n    }\n\n    return this._stateStorage.read(location, key);\n  };\n\n  _proto.scrollToTarget = function scrollToTarget(element, target) {\n    if (typeof target === 'string') {\n      var targetElement = document.getElementById(target) || document.getElementsByName(target)[0];\n\n      if (targetElement) {\n        targetElement.scrollIntoView();\n        return;\n      } // Fallback to scrolling to top when target fragment doesn't exist.\n\n\n      target = [0, 0]; // eslint-disable-line no-param-reassign\n    }\n\n    var _target = target,\n        left = _target[0],\n        top = _target[1];\n    (0, _scrollLeft[\"default\"])(element, left);\n    (0, _scrollTop[\"default\"])(element, top);\n  };\n\n  return ScrollBehavior;\n}();\n\nexports[\"default\"] = ScrollBehavior;\nmodule.exports = exports.default;","map":{"version":3,"sources":["/Users/s.vladimirov/Project/React/kancelaria/node_modules/scroll-behavior/lib/index.js"],"names":["exports","__esModule","_off","_interopRequireDefault","require","_on","_scrollLeft","_scrollTop","_requestAnimationFrame","_invariant","_utils","obj","MAX_SCROLL_ATTEMPTS","ScrollBehavior","_ref","_this","addTransitionHook","stateStorage","getCurrentLocation","shouldUpdateScroll","_restoreScrollRestoration","_oldScrollRestoration","window","history","scrollRestoration","e","_onWindowScroll","_ignoreScrollEvents","_saveWindowPositionHandle","_saveWindowPosition","_windowScrollTarget","_this$_windowScrollTa","xTarget","yTarget","x","y","_cancelCheckWindowScroll","_savePosition","_checkWindowScrollPosition","_checkWindowScrollHandle","Promise","resolve","scrollToTarget","_numWindowScrollAttempts","_stateStorage","_getCurrentLocation","_shouldUpdateScroll","isMobileSafari","_scrollElements","_removeTransitionHook","cancel","Object","keys","forEach","key","scrollElement","savePositionHandle","_saveElementPosition","_proto","prototype","registerElement","element","context","_this2","process","env","NODE_ENV","invariant","saveElementPosition","onScroll","_updateElementScroll","unregisterElement","_this$_scrollElements","updateScroll","prevContext","_this3","_updateWindowScroll","then","stop","startIgnoringScrollEvents","stopIgnoringScrollEvents","save","_getScrollTarget","_this$_scrollElements2","scrollTarget","_getDefaultScrollTarget","location","hash","charAt","slice","call","Array","isArray","_getSavedScrollTarget","action","read","target","targetElement","document","getElementById","getElementsByName","scrollIntoView","_target","left","top","module","default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _off = _interopRequireDefault(require(\"dom-helpers/events/off\"));\n\nvar _on = _interopRequireDefault(require(\"dom-helpers/events/on\"));\n\nvar _scrollLeft = _interopRequireDefault(require(\"dom-helpers/query/scrollLeft\"));\n\nvar _scrollTop = _interopRequireDefault(require(\"dom-helpers/query/scrollTop\"));\n\nvar _requestAnimationFrame = _interopRequireDefault(require(\"dom-helpers/util/requestAnimationFrame\"));\n\nvar _invariant = _interopRequireDefault(require(\"invariant\"));\n\nvar _utils = require(\"./utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/* eslint-disable no-underscore-dangle */\n// Try at most this many times to scroll, to avoid getting stuck.\nvar MAX_SCROLL_ATTEMPTS = 2;\n\nvar ScrollBehavior = /*#__PURE__*/function () {\n  function ScrollBehavior(_ref) {\n    var _this = this;\n\n    var addTransitionHook = _ref.addTransitionHook,\n        stateStorage = _ref.stateStorage,\n        getCurrentLocation = _ref.getCurrentLocation,\n        shouldUpdateScroll = _ref.shouldUpdateScroll;\n\n    this._restoreScrollRestoration = function () {\n      /* istanbul ignore if: not supported by any browsers on Travis */\n      if (_this._oldScrollRestoration) {\n        try {\n          window.history.scrollRestoration = _this._oldScrollRestoration;\n        } catch (e) {\n          /* silence */\n        }\n      }\n    };\n\n    this._onWindowScroll = function () {\n      if (_this._ignoreScrollEvents) {\n        // Don't save the scroll position until the transition is complete\n        return;\n      } // It's possible that this scroll operation was triggered by what will be a\n      // `POP` transition. Instead of updating the saved location immediately, we\n      // have to enqueue the update, then potentially cancel it if we observe a\n      // location update.\n\n\n      if (!_this._saveWindowPositionHandle) {\n        _this._saveWindowPositionHandle = (0, _requestAnimationFrame[\"default\"])(_this._saveWindowPosition);\n      }\n\n      if (_this._windowScrollTarget) {\n        var _this$_windowScrollTa = _this._windowScrollTarget,\n            xTarget = _this$_windowScrollTa[0],\n            yTarget = _this$_windowScrollTa[1];\n        var x = (0, _scrollLeft[\"default\"])(window);\n        var y = (0, _scrollTop[\"default\"])(window);\n\n        if (x === xTarget && y === yTarget) {\n          _this._windowScrollTarget = null;\n\n          _this._cancelCheckWindowScroll();\n        }\n      }\n    };\n\n    this._saveWindowPosition = function () {\n      _this._saveWindowPositionHandle = null;\n\n      _this._savePosition(null, window);\n    };\n\n    this._checkWindowScrollPosition = function () {\n      _this._checkWindowScrollHandle = null; // We can only get here if scrollTarget is set. Every code path that unsets\n      // scroll target also cancels the handle to avoid calling this handler.\n      // Still, check anyway just in case.\n\n      /* istanbul ignore if: paranoid guard */\n\n      if (!_this._windowScrollTarget) {\n        return Promise.resolve();\n      }\n\n      _this.scrollToTarget(window, _this._windowScrollTarget);\n\n      ++_this._numWindowScrollAttempts;\n      /* istanbul ignore if: paranoid guard */\n\n      if (_this._numWindowScrollAttempts >= MAX_SCROLL_ATTEMPTS) {\n        // This might happen if the scroll position was already set to the target\n        _this._windowScrollTarget = null;\n        return Promise.resolve();\n      }\n\n      return new Promise(function (resolve) {\n        _this._checkWindowScrollHandle = (0, _requestAnimationFrame[\"default\"])(function () {\n          return resolve(_this._checkWindowScrollPosition());\n        });\n      });\n    };\n\n    this._stateStorage = stateStorage;\n    this._getCurrentLocation = getCurrentLocation;\n    this._shouldUpdateScroll = shouldUpdateScroll; // This helps avoid some jankiness in fighting against the browser's\n    // default scroll behavior on `POP` transitions.\n\n    /* istanbul ignore else: Travis browsers all support this */\n\n    if ('scrollRestoration' in window.history && // Unfortunately, Safari on iOS freezes for 2-6s after the user swipes to\n    // navigate through history with scrollRestoration being 'manual', so we\n    // need to detect this browser and exclude it from the following code\n    // until this bug is fixed by Apple.\n    !(0, _utils.isMobileSafari)()) {\n      this._oldScrollRestoration = window.history.scrollRestoration;\n\n      try {\n        window.history.scrollRestoration = 'manual'; // Scroll restoration persists across page reloads. We want to reset\n        // this to the original value, so that we can let the browser handle\n        // restoring the initial scroll position on server-rendered pages.\n\n        (0, _on[\"default\"])(window, 'beforeunload', this._restoreScrollRestoration);\n      } catch (e) {\n        this._oldScrollRestoration = null;\n      }\n    } else {\n      this._oldScrollRestoration = null;\n    }\n\n    this._saveWindowPositionHandle = null;\n    this._checkWindowScrollHandle = null;\n    this._windowScrollTarget = null;\n    this._numWindowScrollAttempts = 0;\n    this._ignoreScrollEvents = false;\n    this._scrollElements = {}; // We have to listen to each window scroll update rather than to just\n    // location updates, because some browsers will update scroll position\n    // before emitting the location change.\n\n    (0, _on[\"default\"])(window, 'scroll', this._onWindowScroll);\n    this._removeTransitionHook = addTransitionHook(function () {\n      _requestAnimationFrame[\"default\"].cancel(_this._saveWindowPositionHandle);\n\n      _this._saveWindowPositionHandle = null;\n      Object.keys(_this._scrollElements).forEach(function (key) {\n        var scrollElement = _this._scrollElements[key];\n\n        _requestAnimationFrame[\"default\"].cancel(scrollElement.savePositionHandle);\n\n        scrollElement.savePositionHandle = null; // It's fine to save element scroll positions here, though; the browser\n        // won't modify them.\n\n        if (!_this._ignoreScrollEvents) {\n          _this._saveElementPosition(key);\n        }\n      });\n    });\n  }\n\n  var _proto = ScrollBehavior.prototype;\n\n  _proto.registerElement = function registerElement(key, element, shouldUpdateScroll, context) {\n    var _this2 = this;\n\n    !!this._scrollElements[key] ? process.env.NODE_ENV !== \"production\" ? (0, _invariant[\"default\"])(false, 'ScrollBehavior: There is already an element registered for `%s`.', key) : invariant(false) : void 0;\n\n    var saveElementPosition = function saveElementPosition() {\n      _this2._saveElementPosition(key);\n    };\n\n    var scrollElement = {\n      element: element,\n      shouldUpdateScroll: shouldUpdateScroll,\n      savePositionHandle: null,\n      onScroll: function onScroll() {\n        if (!scrollElement.savePositionHandle && !_this2._ignoreScrollEvents) {\n          scrollElement.savePositionHandle = (0, _requestAnimationFrame[\"default\"])(saveElementPosition);\n        }\n      }\n    }; // In case no scrolling occurs, save the initial position\n\n    if (!scrollElement.savePositionHandle && !this._ignoreScrollEvents) {\n      scrollElement.savePositionHandle = (0, _requestAnimationFrame[\"default\"])(saveElementPosition);\n    }\n\n    this._scrollElements[key] = scrollElement;\n    (0, _on[\"default\"])(element, 'scroll', scrollElement.onScroll);\n\n    this._updateElementScroll(key, null, context);\n  };\n\n  _proto.unregisterElement = function unregisterElement(key) {\n    !this._scrollElements[key] ? process.env.NODE_ENV !== \"production\" ? (0, _invariant[\"default\"])(false, 'ScrollBehavior: There is no element registered for `%s`.', key) : invariant(false) : void 0;\n    var _this$_scrollElements = this._scrollElements[key],\n        element = _this$_scrollElements.element,\n        onScroll = _this$_scrollElements.onScroll,\n        savePositionHandle = _this$_scrollElements.savePositionHandle;\n    (0, _off[\"default\"])(element, 'scroll', onScroll);\n\n    _requestAnimationFrame[\"default\"].cancel(savePositionHandle);\n\n    delete this._scrollElements[key];\n  };\n\n  _proto.updateScroll = function updateScroll(prevContext, context) {\n    var _this3 = this;\n\n    this._updateWindowScroll(prevContext, context).then(function () {\n      // Save the position immediately after a transition so that if no\n      // scrolling occurs, there is still a saved position\n      if (!_this3._saveWindowPositionHandle) {\n        _this3._saveWindowPositionHandle = (0, _requestAnimationFrame[\"default\"])(_this3._saveWindowPosition);\n      }\n    });\n\n    Object.keys(this._scrollElements).forEach(function (key) {\n      _this3._updateElementScroll(key, prevContext, context);\n    });\n  };\n\n  _proto.stop = function stop() {\n    this._restoreScrollRestoration();\n\n    (0, _off[\"default\"])(window, 'scroll', this._onWindowScroll);\n\n    this._cancelCheckWindowScroll();\n\n    this._removeTransitionHook();\n  };\n\n  _proto.startIgnoringScrollEvents = function startIgnoringScrollEvents() {\n    this._ignoreScrollEvents = true;\n  };\n\n  _proto.stopIgnoringScrollEvents = function stopIgnoringScrollEvents() {\n    this._ignoreScrollEvents = false;\n  };\n\n  _proto._cancelCheckWindowScroll = function _cancelCheckWindowScroll() {\n    _requestAnimationFrame[\"default\"].cancel(this._checkWindowScrollHandle);\n\n    this._checkWindowScrollHandle = null;\n  };\n\n  _proto._saveElementPosition = function _saveElementPosition(key) {\n    var scrollElement = this._scrollElements[key];\n    scrollElement.savePositionHandle = null;\n\n    this._savePosition(key, scrollElement.element);\n  };\n\n  _proto._savePosition = function _savePosition(key, element) {\n    this._stateStorage.save(this._getCurrentLocation(), key, [(0, _scrollLeft[\"default\"])(element), (0, _scrollTop[\"default\"])(element)]);\n  };\n\n  _proto._updateWindowScroll = function _updateWindowScroll(prevContext, context) {\n    // Whatever we were doing before isn't relevant any more.\n    this._cancelCheckWindowScroll();\n\n    this._windowScrollTarget = this._getScrollTarget(null, this._shouldUpdateScroll, prevContext, context); // Updating the window scroll position is really flaky. Just trying to\n    // scroll it isn't enough. Instead, try to scroll a few times until it\n    // works.\n\n    this._numWindowScrollAttempts = 0;\n    return this._checkWindowScrollPosition();\n  };\n\n  _proto._updateElementScroll = function _updateElementScroll(key, prevContext, context) {\n    var _this$_scrollElements2 = this._scrollElements[key],\n        element = _this$_scrollElements2.element,\n        shouldUpdateScroll = _this$_scrollElements2.shouldUpdateScroll;\n\n    var scrollTarget = this._getScrollTarget(key, shouldUpdateScroll, prevContext, context);\n\n    if (!scrollTarget) {\n      return;\n    } // Unlike with the window, there shouldn't be any flakiness to deal with\n    // here.\n\n\n    this.scrollToTarget(element, scrollTarget);\n  };\n\n  _proto._getDefaultScrollTarget = function _getDefaultScrollTarget(location) {\n    var hash = location.hash;\n\n    if (hash && hash !== '#') {\n      return hash.charAt(0) === '#' ? hash.slice(1) : hash;\n    }\n\n    return [0, 0];\n  };\n\n  _proto._getScrollTarget = function _getScrollTarget(key, shouldUpdateScroll, prevContext, context) {\n    var scrollTarget = shouldUpdateScroll ? shouldUpdateScroll.call(this, prevContext, context) : true;\n\n    if (!scrollTarget || Array.isArray(scrollTarget) || typeof scrollTarget === 'string') {\n      return scrollTarget;\n    }\n\n    var location = this._getCurrentLocation();\n\n    return this._getSavedScrollTarget(key, location) || this._getDefaultScrollTarget(location);\n  };\n\n  _proto._getSavedScrollTarget = function _getSavedScrollTarget(key, location) {\n    if (location.action === 'PUSH') {\n      return null;\n    }\n\n    return this._stateStorage.read(location, key);\n  };\n\n  _proto.scrollToTarget = function scrollToTarget(element, target) {\n    if (typeof target === 'string') {\n      var targetElement = document.getElementById(target) || document.getElementsByName(target)[0];\n\n      if (targetElement) {\n        targetElement.scrollIntoView();\n        return;\n      } // Fallback to scrolling to top when target fragment doesn't exist.\n\n\n      target = [0, 0]; // eslint-disable-line no-param-reassign\n    }\n\n    var _target = target,\n        left = _target[0],\n        top = _target[1];\n    (0, _scrollLeft[\"default\"])(element, left);\n    (0, _scrollTop[\"default\"])(element, top);\n  };\n\n  return ScrollBehavior;\n}();\n\nexports[\"default\"] = ScrollBehavior;\nmodule.exports = exports.default;"]},"metadata":{},"sourceType":"script"}